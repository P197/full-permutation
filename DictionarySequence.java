package 全排列算法;

public class DictionarySequence {
	/*
	 * 核心思想就是找到比上一次排列的数大的数中最小的那个数 如何找到这个数。
	 * 因为一开始我们传递过来的数是从小到大排序的，最后一个数是最大的，第一个数是最小的 那么要找到比当前数大的且在大于当前数种最小的那个数怎么找？
	 * 这是一个逐渐把升序的数转换为降序的过程
	 * 
	 * 例】 如何得到346987521的下一个 从尾部往前找第一个P(i-1) < P(i)的位置 3 4 6 <- 9 <- 8 <- 7 <- 5
	 * <-2 <- 1 最终找到6是第一个变小的数字 记录下6的位置i-1 2，从i位置往后找到最后一个大于6的数 3 4 6 -> 9 -> 8 ->
	 * 7 5 2 1 最终找到7的位置 记录位置为m 3，交换位置i-1和m的值 3 4 7 9 8 6 5 2 1 4，倒序i位置后的所有数据 3 4
	 * 7 1 2 5 6 8 9 则347125689为346987521的下一个排列
	 * 
	 * 且分析发现，该方式具有先去重优势，不用进行任何处理就已经去除了重复的排列
	 * 
	 * @param a 待排列数组
	 * @param n 数组长度
	 */
	public static void pailie(int a[], int n) {
		int i;
		int j = 0, k;
		// 这一套的基本思路就是在每一个从右向左数周到的第一个比自己右边小的数字的右边的数
		// 每一次排列都是从一组升序的数一直排到一组降序的数
		while (true) {
			// 输出结果
			for (i = 0; i < n; i++){
				 //System.out.printf("%d", a[i]);
			}
			//System.out.println("");
			
			// 这一步是从这一组数中右边(即从倒数第二个数判断，因为倒数第一个数右边没有数字）
			// 开始判断，找出第一个比自己右边数字小的数，下标存到j中
			for (j = n - 2; j >= 0 && a[j] >= a[j + 1]; j--);

			// 当已经找不到还有比自己右边数字小的数的时候，就说明所有的全排列已经找到了
			// 出因为字典序全排列就是从一个最小的数，一直到最大的数1234----4321，当输到最大时，全排列就全部输出了
			if (j < 0)
				return;
			
			// 找到j右边的比j大的最小的那个数的下标，一定能找到一个比当前j位置大的数。
			for (k = j + 1; k < n && a[j] < a[k]; k++);
			
			// 交换两个数的位置。为了得到比当前排列数大的下一个排列。
			swap(a, k-1, j);
			
			/*
			 * 因为每一次一段数字排列完后，在j后面的数字最后都会是一个降序的数，
			 * j这个位置的数字后面的数是从大到小排序的，给对调一下就得出了下一次要输出的全排列
			 */
			for (int l = j + 1, r = n - 1; l < r; l++, r--)
				swap(a, l, r);

		}

	}

	public static void swap(int[] nums, int l, int r) {
		int temp = nums[l];
		nums[l] = nums[r];
		nums[r] = temp;
	}
}
